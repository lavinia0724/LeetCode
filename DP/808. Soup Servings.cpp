// 2025/08/08
class Solution {
public:
    double soupServings(int n) {
        if (n > 5000) return 1.0; // 因為當 n 很大時，A 總是比 B 更容易先倒完(A沒有case會不倒水)，機率會迅速趨近 1，n ≥ 5000 時與 1 的差距已小於 10⁻⁵，所以可直接回傳 1.0

        // ceil: 無條件向上取整，記得要用浮點數；ex: 1 / 25 = 0.0 向上取整還是 0，但 1 / 25.0 = 0.04 向上取整為 1，有差
        int m = ceil(n / 25.0); // 以 25 為單位，看 n 需要多少單位才能倒完
        vector<vector<double>> dp(m+1, vector<double>(m+1, 0.0));
        dp[0][0] = 0.5; // 初始化，[0][0] 代表 A B 都是空的，平手的成績是 1 / 2 = 0.5

        // dp[i][j] 代表 A 倒了 i 個 25 單位，B 倒了 j 個 25 單位
        for(int i = 1; i <= m; ++i){ 
            dp[i][0] = 0.0; // 因為如果 [i][0] 代表 B 先空了，此時獲勝機率為 0
            dp[0][i] = 1.0; // 同理，[0][i] 代表 A 先空了，此時獲勝機率為 1
            for(int j = 1; j <= i; ++j){
                // 其實可以發現每次倒水都是 4 個 25 單位的總和，所以這裏去找能組成現在這格水量的那四種倒水法
                // ex: [i-4][j] 代表的是少 4*25 單位前的 dp 狀態，因為如果該狀態我倒了 100ml A、0 ml B 之後就會變成現在的 [i][j] 狀態
                // ex: dp[1][1] 代表的是 A 和 B 目前都各有 25 ml 的機率
                // 最後除以 4，因為這裡每個 dp 發生機率都是 0.25
                dp[i][j] = (dp[max(0, i-4)][max(0, j)] + dp[max(0, i-3)][max(0, j-1)] + dp[max(0, i-2)][max(0, j-2)] + dp[max(0, i-1)][max(0, j-3)]) / 4;
                dp[j][i] = (dp[max(0, j-4)][max(0, i)] + dp[max(0, j-3)][max(0, i-1)] + dp[max(0, j-2)][max(0, i-2)] + dp[max(0, j-1)][max(0, i-3)]) / 4;
            } 
        }
        return dp[m][m];
    }
};